import skimage.measure
import numpy as np
import math
import itertools
import sys
import csv

from segmetrics.metric import Metric


def _is_boolean(narray):
    return narray.dtype == bool


def _is_integral(narray):
    return issubclass(narray.dtype.type, np.integer)


def _get_labeled(narray, unique, img_hint):
    assert _is_integral(narray) or _is_boolean(narray), 'illegal %s dtype' % img_hint
    assert not unique or not _is_boolean(narray), 'with unique=True a non-boolean %s is expected' % img_hint
    return narray if unique else label(narray)


def _get_skimage_measure_label_bg_label():
    """Determines the background label generated by the `label` routine of `skimage.measure`.

    The value of the background label varies from version to version.
    """
    return skimage.measure.label(np.array([[1, 0]]), background=0).min()

_SKIMAGE_MEASURE_LABEL_BF_LABEL = _get_skimage_measure_label_bg_label()


def label(im, background=0, neighbors=4):
    """Labels the given image `im`.
    
    Returns a labeled version of `im` where `background` is labeled with
    0 and all other connected components are labeled with values larger
    than or equal to 1.
    """
    assert neighbors in (4, 8)
    connectivity = int(math.log2(neighbors)) - 1
    return skimage.measure.label(im, background=background, connectivity=connectivity) \
        - _SKIMAGE_MEASURE_LABEL_BF_LABEL # this is 1 in older versions and 0 in newer


def aggregate(measure, values):
    fnc = np.sum if measure.ACCUMULATIVE else np.mean
    return fnc(values)


class Study:

    def __init__(self):
        self.measures   = dict()
        self.sample_ids = list()
        self.results    = dict()
        self.results_cache = dict()
        self.csv_sample_id_column_name = 'Sample'

    def merge(self, other, sample_ids='all'):
        """Merges measures and results from `other` study.
        """
        for measure_name in other.measures:
            if measure_name not in self.measures.keys():
                self.add_measure(other.measures[measure_name], name=measure_name)
            for sample_id in (other.results[measure_name].keys() if sample_ids == 'all' else sample_ids):
                if sample_id is None:
                    self.results[measure_name][None] += other.results[measure_name][None]
                else:
                    assert sample_id not in self.results[measure_name]
                    self.results[measure_name][sample_id] = list(other.results[measure_name][sample_id])
        self.results_cache.clear()

    def add_measure(self, measure, name=None):
        if not isinstance(measure, Metric): raise ValueError('measure must be a Metric object')
        if name is None: name = '%d' % id(measure)
        self.measures[name] = measure
        self.results [name] = {None: []}

    def reset(self):
        """Resets all results computed so far.
        """
        for measure_name in self.measures:
            self.results[measure_name] = {None: []}
        self.results_cache.clear()
        self.sample_ids.clear()

    def set_expected(self, expected, unique=True):
        """Sets the `expected` ground truth image.
        
        The background must be labeled as 0. Negative object labels are
        forbidden. If `unique` is `True`, it is assumed that all objects
        are labeled uniquely. Set it to `False`, if this is not sure
        (e.g., if the ground truth image is binary).

        The array `expected` must be of integral datatype. It is also
        allowed to be boolean if and only if `unique=False` is passed.
        """
        assert expected.min() == 0, 'mis-labeled ground truth'
        expected = expected.squeeze()
        assert expected.ndim == 2, 'ground truth has wrong dimensions'
        expected = _get_labeled(expected, unique, 'ground truth')
        for measure_name in self.measures:
            measure = self.measures[measure_name]
            measure.set_expected(expected)

    def process(self, sample_id, actual, unique=True):
        """Evaluates `actual` image against the current `set_expected` one.
        
        If `unique` is `True`, it is assumed that all objects are labeled
        uniquely. Set it to `False`, if this is not sure (e.g., if the
        processed image is binary).

        The array `actual` must be of integral datatype. It is also
        allowed to be boolean if and only if `unique=False` is passed.

        All results ever processed are accumulated, unless `chunk_id` is
        used. If it is not set to `None`, then a subsequent invocation
        with the same `chunk_id` will overwrite the results from the
        previous invocation.
        """
        actual = actual.squeeze()
        assert actual.ndim == 2, 'image has wrong dimensions'
        actual = _get_labeled(actual, unique, 'image')
        if sample_id in self.sample_ids: raise ValueError(f'sample_id="{sample_id}" already used')
        intermediate_results = {}
        for measure_name in self.measures:
            measure = self.measures[measure_name]
            result = measure.compute(actual)
            self.results[measure_name][sample_id] = result
            intermediate_results[measure_name] = result
        self.results_cache.clear()
        self.sample_ids.append(sample_id)
        return intermediate_results

    def __getitem__(self, measure):
        """Returns list of all values recorded for given `measure`.
        """
        if measure not in self.results_cache:
            self.results_cache[measure] = list(itertools.chain(*[self.results[measure][sample_id] for sample_id in self.results[measure]]))
        return self.results_cache[measure]

    def print_results(self, write=sys.stdout.write, pad=0, fmt_unbound_float='g', line_suffix='\n'):
        label_length   = pad + max(len(str(measure_name)) for measure_name in self.results)
        fmt_fractional = '%%%ds: %%5.2f %%%%' % label_length
        fmt_unbound    = '%%%ds: %%%s' % (label_length, fmt_unbound_float)
        for measure_name in sorted(self.results.keys()):
            measure = self.measures[measure_name]
            fmt = fmt_fractional if measure.FRACTIONAL else fmt_unbound
            val = aggregate(measure, self[measure_name]) * (100 if measure.FRACTIONAL else 1)
            write((fmt % (measure_name, val)) + line_suffix)

    def write_csv(self, fout, write_samples='auto', write_header=True, write_summary=True, **kwargs):
        kwargs.setdefault('delimiter', ',')
        kwargs.setdefault('quotechar', '"')
        kwargs.setdefault('quoting', csv.QUOTE_MINIMAL)
        rows = list()

        # define header
        if write_header:
            rows += [[self.csv_sample_id_column_name] + [measure_name for measure_name in self.measures.keys()]]

	# define samples
        if write_samples == True or (write_samples == 'auto' and len(self.sample_ids) > 1):
            for sample_id in self.sample_ids:
                row = [sample_id]
                for measure_name in self.measures.keys():
                    measure = self.measures[measure_name]
                    samples = self.results[measure_name]
                    row += [aggregate(measure, samples[sample_id])]
                rows.append(row)

        # define summary
        if write_summary:
            rows.append([''])
            for measure_name in self.measures.keys():
                measure = self.measures[measure_name]
                value = aggregate(measure, self[measure_name])
                rows[-1].append(value)

        # write results
        csv_writer = csv.writer(fout, **kwargs)
        for row in rows:
            csv_writer.writerow(row)

    def write_tsv(self, fout, **kwargs):
        kwargs.setdefault('delimiter', '\t')
        return self.write_csv(fout, **kwargs)

    def todf(self):
        import pandas as pd
        import io
        buf = io.StringIO()
        self.write_csv(buf, delimiter=',')
        buf.seek(0)
        df = pd.read_csv(buf, sep=',', keep_default_na=False)
        return df

